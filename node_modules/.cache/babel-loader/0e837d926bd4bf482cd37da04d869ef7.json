{"ast":null,"code":"import _objectSpread from\"C:/Users/Admin/Desktop/react-firechat-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _slicedToArray from\"C:/Users/Admin/Desktop/react-firechat-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useEffect,useState,useRef,useCallback}from'react';export function useFirestoreQuery(query){var _useState=useState([]),_useState2=_slicedToArray(_useState,2),docs=_useState2[0],setDocs=_useState2[1];// Store current query in ref\nvar queryRef=useRef(query);// Compare current query with the previous one\nuseEffect(function(){var _queryRef$curent;// Use Firestore built-in 'isEqual' method\n// to compare queries\nif(!(queryRef===null||queryRef===void 0?void 0:(_queryRef$curent=queryRef.curent)===null||_queryRef$curent===void 0?void 0:_queryRef$curent.isEqual(query))){queryRef.current=query;}});// Re-run data listener only if query has changed\nuseEffect(function(){if(!queryRef.current){return null;}// Subscribe to query with onSnapshot\nvar unsubscribe=queryRef.current.onSnapshot(function(querySnapshot){// Get all documents from collection - with IDs\nvar data=querySnapshot.docs.map(function(doc){return _objectSpread(_objectSpread({},doc.data()),{},{id:doc.id});});// Update state\nsetDocs(data);});// Detach listener\nreturn unsubscribe;},[queryRef]);return docs;}export function useAuthState(auth){var _useState3=useState(true),_useState4=_slicedToArray(_useState3,2),initializing=_useState4[0],setInitializing=_useState4[1];var _useState5=useState(function(){return auth.currentUser;}),_useState6=_slicedToArray(_useState5,2),user=_useState6[0],setUser=_useState6[1];useEffect(function(){var unsubscribe=auth.onAuthStateChanged(function(user){if(user){setUser(user);}else{setUser(false);}if(initializing){setInitializing(false);}});// Cleanup subscription\nreturn unsubscribe;},[auth,initializing]);return{user:user,initializing:initializing};}export function useLocalStorage(key,initialValue){// State to store our value\n// Pass initial state function to useState so logic is only executed once\nvar _useState7=useState(function(){try{// Get from local storage by key\nvar item=window.localStorage.getItem(key);// Parse stored json or if none return initialValue\nreturn item?JSON.parse(item):initialValue;}catch(error){// If error also return initialValue\nconsole.log(error);return initialValue;}}),_useState8=_slicedToArray(_useState7,2),storedValue=_useState8[0],setStoredValue=_useState8[1];// Return a wrapped version of useState's setter function that ...\n// ... persists the new value to localStorage.\nvar setValue=function setValue(value){try{// Allow value to be a function so we have same API as useState\nvar valueToStore=value instanceof Function?value(storedValue):value;// Save state\nsetStoredValue(valueToStore);// Save to local storage\nwindow.localStorage.setItem(key,JSON.stringify(valueToStore));}catch(error){// A more advanced implementation would handle the error case\nconsole.log(error);}};return[storedValue,setValue];}export function useMedia(queries,values,defaultValue){// Array containing a media query list for each query\nvar mediaQueryLists=queries.map(function(q){return window.matchMedia(q);});// Function that gets value based on matching media query\nvar getValue=useCallback(function(){// Get index of first media query that matches\nvar index=mediaQueryLists.findIndex(function(mql){return mql.matches;});// Return related value or defaultValue if none\nreturn typeof values[index]!=='undefined'?values[index]:defaultValue;},[mediaQueryLists,values,defaultValue]);// State and setter for matched value\nvar _useState9=useState(getValue),_useState10=_slicedToArray(_useState9,2),value=_useState10[0],setValue=_useState10[1];useEffect(function(){// Event listener callback\n// Note: By defining getValue outside of useEffect we ensure that it has ...\n// ... current values of hook args (as this hook callback is created once on mount).\nvar handler=function handler(){return setValue(getValue);};// Set a listener for each media query with above handler as callback.\nmediaQueryLists.forEach(function(mql){return mql.addListener(handler);});// Remove listeners on cleanup\nreturn function(){return mediaQueryLists.forEach(function(mql){return mql.removeListener(handler);});};},[getValue,mediaQueryLists]);return value;}export function useDarkMode(){// See if user has set a browser or OS preference for dark mode.\nvar prefersDarkMode=useMedia(['(prefers-color-scheme: dark)'],[true],false);// Use our useLocalStorage hook to persist state through a page refresh\nvar _useLocalStorage=useLocalStorage('dark-mode-enabled',prefersDarkMode),_useLocalStorage2=_slicedToArray(_useLocalStorage,2),enabled=_useLocalStorage2[0],setEnabled=_useLocalStorage2[1];// Fire off effect that add/removes dark mode class\nuseEffect(function(){var className='dark';var element=window.document.body;if(enabled){element.classList.add(className);}else{element.classList.remove(className);}},[enabled]// Only re-call effect when value changes\n);// Return enabled state and setter\nreturn[enabled,setEnabled];}","map":{"version":3,"sources":["C:/Users/Admin/Desktop/react-firechat-master/src/hooks.js"],"names":["useEffect","useState","useRef","useCallback","useFirestoreQuery","query","docs","setDocs","queryRef","curent","isEqual","current","unsubscribe","onSnapshot","querySnapshot","data","map","doc","id","useAuthState","auth","initializing","setInitializing","currentUser","user","setUser","onAuthStateChanged","useLocalStorage","key","initialValue","item","window","localStorage","getItem","JSON","parse","error","console","log","storedValue","setStoredValue","setValue","value","valueToStore","Function","setItem","stringify","useMedia","queries","values","defaultValue","mediaQueryLists","q","matchMedia","getValue","index","findIndex","mql","matches","handler","forEach","addListener","removeListener","useDarkMode","prefersDarkMode","enabled","setEnabled","className","element","document","body","classList","add","remove"],"mappings":"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","sourcesContent":["import { useEffect, useState, useRef, useCallback } from 'react';\n\nexport function useFirestoreQuery(query) {\n  const [docs, setDocs] = useState([]);\n\n  // Store current query in ref\n  const queryRef = useRef(query);\n\n  // Compare current query with the previous one\n  useEffect(() => {\n    // Use Firestore built-in 'isEqual' method\n    // to compare queries\n    if (!queryRef?.curent?.isEqual(query)) {\n      queryRef.current = query;\n    }\n  });\n\n  // Re-run data listener only if query has changed\n  useEffect(() => {\n    if (!queryRef.current) {\n      return null;\n    }\n\n    // Subscribe to query with onSnapshot\n    const unsubscribe = queryRef.current.onSnapshot(querySnapshot => {\n      // Get all documents from collection - with IDs\n      const data = querySnapshot.docs.map(doc => ({\n        ...doc.data(),\n        id: doc.id,\n      }));\n      // Update state\n      setDocs(data);\n    });\n\n    // Detach listener\n    return unsubscribe;\n  }, [queryRef]);\n\n  return docs;\n}\n\nexport function useAuthState(auth) {\n  const [initializing, setInitializing] = useState(true);\n  const [user, setUser] = useState(() => auth.currentUser);\n\n  useEffect(() => {\n    const unsubscribe = auth.onAuthStateChanged(user => {\n      if (user) {\n        setUser(user);\n      } else {\n        setUser(false);\n      }\n      if (initializing) {\n        setInitializing(false);\n      }\n    });\n\n    // Cleanup subscription\n    return unsubscribe;\n  }, [auth, initializing]);\n\n  return { user, initializing };\n}\n\nexport function useLocalStorage(key, initialValue) {\n  // State to store our value\n  // Pass initial state function to useState so logic is only executed once\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      // Get from local storage by key\n      const item = window.localStorage.getItem(key);\n      // Parse stored json or if none return initialValue\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      // If error also return initialValue\n      console.log(error);\n      return initialValue;\n    }\n  });\n\n  // Return a wrapped version of useState's setter function that ...\n  // ... persists the new value to localStorage.\n  const setValue = value => {\n    try {\n      // Allow value to be a function so we have same API as useState\n      const valueToStore =\n        value instanceof Function ? value(storedValue) : value;\n      // Save state\n      setStoredValue(valueToStore);\n      // Save to local storage\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      // A more advanced implementation would handle the error case\n      console.log(error);\n    }\n  };\n\n  return [storedValue, setValue];\n}\n\nexport function useMedia(queries, values, defaultValue) {\n  // Array containing a media query list for each query\n  const mediaQueryLists = queries.map(q => window.matchMedia(q));\n\n  // Function that gets value based on matching media query\n  const getValue = useCallback(() => {\n    // Get index of first media query that matches\n    const index = mediaQueryLists.findIndex(mql => mql.matches);\n    // Return related value or defaultValue if none\n    return typeof values[index] !== 'undefined' ? values[index] : defaultValue;\n  }, [mediaQueryLists, values, defaultValue]);\n\n  // State and setter for matched value\n  const [value, setValue] = useState(getValue);\n\n  useEffect(() => {\n    // Event listener callback\n    // Note: By defining getValue outside of useEffect we ensure that it has ...\n    // ... current values of hook args (as this hook callback is created once on mount).\n    const handler = () => setValue(getValue);\n    // Set a listener for each media query with above handler as callback.\n    mediaQueryLists.forEach(mql => mql.addListener(handler));\n    // Remove listeners on cleanup\n    return () => mediaQueryLists.forEach(mql => mql.removeListener(handler));\n  }, [getValue, mediaQueryLists]);\n\n  return value;\n}\n\nexport function useDarkMode() {\n  // See if user has set a browser or OS preference for dark mode.\n  const prefersDarkMode = useMedia(\n    ['(prefers-color-scheme: dark)'],\n    [true],\n    false\n  );\n\n  // Use our useLocalStorage hook to persist state through a page refresh\n  const [enabled, setEnabled] = useLocalStorage(\n    'dark-mode-enabled',\n    prefersDarkMode\n  );\n\n  // Fire off effect that add/removes dark mode class\n  useEffect(\n    () => {\n      const className = 'dark';\n      const element = window.document.body;\n      if (enabled) {\n        element.classList.add(className);\n      } else {\n        element.classList.remove(className);\n      }\n    },\n    [enabled] // Only re-call effect when value changes\n  );\n\n  // Return enabled state and setter\n  return [enabled, setEnabled];\n}\n"]},"metadata":{},"sourceType":"module"}